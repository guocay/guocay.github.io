import{_ as e,X as t,Y as i,Z as r}from"./framework-d314e57d.js";const n="/docs/images/20230611-001.jpg",o="/docs/images/20230611-002.jpg",a="/docs/images/20230626-001.jpg",l="/docs/images/20230626-002.jpg",s="/docs/images/20230626-003.jpg",d={},p=r('<div class="hint-container tip"><p class="hint-container-title">MVCC</p><p>InnoDB存储引擎的并发是通过MVCC(Multi-Version Concurrency Control)实现的. 与MVCC相对的是LBCC(Lock-Based Concurrency Control), 对比来说好处在于 <strong>读写不互斥</strong>. 在读多写少的应用中,读写不冲突是很重要的,可大幅度增加系统的并发性能. 这也是为什么现阶段大部分关系型数据库都是支持MVCC的.</p></div><h2 id="snapshot-read-current-read" tabindex="-1"><a class="header-anchor" href="#snapshot-read-current-read" aria-hidden="true">#</a> Snapshot Read &amp; Current Read</h2><p>在MVCC并发控制中,读操作可以分成两类: 快照读(snapshot read)与当前读(current read).快照读,读取的是记录的可见版本 (有可能是历史版本),不用加锁. 当前读,读取的是记录的最新版本. 并且,当前读返回的记录,都会加上锁,保证其他事务不会再并发修改这条记录.</p><table><thead><tr><th>快照读</th><th>当前读</th></tr></thead><tbody><tr><td>select * from table where ?;</td><td>select * from table where ? lock in share mode;</td></tr><tr><td></td><td>select * from table where ? for update;</td></tr><tr><td></td><td>insert into table values (…);</td></tr><tr><td></td><td>update table set ? where ?;</td></tr><tr><td></td><td>delete from table where ?;</td></tr></tbody></table><p>当前读,读取的是记录的最新版本. 并且,在读取之后还需要保证其他并发事务不能修改当前记录,对当前记录加锁. 除 in share mode 关键字加的是共享锁(S锁)外, 其他语句均加的是排它锁(X锁).</p><h2 id="dml执行过程" tabindex="-1"><a class="header-anchor" href="#dml执行过程" aria-hidden="true">#</a> DML执行过程</h2><figure><img src="'+n+'" alt="更新语句执行过程" tabindex="0" loading="lazy"><figcaption>更新语句执行过程</figcaption></figure><ol><li>Server层在拿到更新语句后, 先开启一个事务(申请一个事务ID).</li><li>Server层根据更新语句先查询出待修改的数据;</li><li>Engine层根据条件查出数据后返回给Server层, 并将返回的数据加锁;</li><li>Server层拿到数据后, 执行逻辑后. 将修改后的数据再次交由Engine层;</li><li>Engine将数据追加到内存缓存池中(后续会再放到undoLog中), 并返回Server层成功;</li><li>Server层接收到修改成功后, 会通过 read next 指令 读取流中的下一批数据重复处理;</li><li>处理完成后, Server层会向Engine层发送事务提交指令. 更新完成;</li></ol><h2 id="two-phase-locking" tabindex="-1"><a class="header-anchor" href="#two-phase-locking" aria-hidden="true">#</a> Two-Phase Locking</h2><p>大部分的关系型数据库加锁的一个原则就是二阶段锁. 二阶段锁相对比较容易理解, 说的是锁的操作分为两个阶段: 加锁阶段和解锁阶段. 并保证加锁阶段与解锁阶段 彼此不相交.</p><p><img src="'+o+'" alt="二阶段锁加锁过程" loading="lazy"> 2PL就是将加锁/解锁分为两个完全不相交的阶段. 加锁阶段: 只加锁,不放锁. 解锁阶段: 只放锁,不加锁.</p><h2 id="事务隔离级别-isolation-level" tabindex="-1"><a class="header-anchor" href="#事务隔离级别-isolation-level" aria-hidden="true">#</a> 事务隔离级别(Isolation Level)</h2><div class="hint-container tip"><p class="hint-container-title">事务隔离级别</p><p>IL简单的讲可以理解为在当前读情况下,事务隔离级别分为四种. 是 &quot;数据库系统&quot; 中的一个概念, 并不局限于InnoDB. 几乎所有的关系型数据库中都会有这个概念. 只是,可能并不四种全部支持.</p><p>在MySQL的事务引擎中,InnoDB是使用最广泛的一种. 它默认的事务隔离级别为RR(重复读).在标准的RR模式下是无法避免幻读问题的,但InnoDB使用了Next-Key Lock(行锁加间歇锁)避免了幻读问题.</p></div><blockquote><p><strong>Read UnCommitted</strong></p></blockquote><p>可以读取到未提交的记录,几乎不会使用.因为无法保证事务的隔离性.</p><blockquote><p><strong>Read Committed</strong></p></blockquote><p>通过对读取到的记录加锁实现.所以可以解决脏读问题,但依旧会出现幻读的情况.</p><blockquote><p><strong>Repeatable Read</strong></p></blockquote><p>通过对读取到的记录加锁实现,并在满足查询条件的区间加间歇锁.所以不会出现幻读情况.</p><blockquote><p><strong>Serializable</strong></p></blockquote><p>将并发控制降低到悲观锁级别,快照读会退化成当前读.不会出现问题,但并发效率会降低.</p><h2 id="sql语句的加锁过程分析" tabindex="-1"><a class="header-anchor" href="#sql语句的加锁过程分析" aria-hidden="true">#</a> SQL语句的加锁过程分析</h2><blockquote><p>针对与读操作.除在事务隔离级别为Serializable模式下,才会对符合条件的数据(和数据区间)进行加锁.其他情况下是不会对数据进行加锁的.</p></blockquote><blockquote><p>针对与写操作.在不同事务隔离级别下, 查询条件是否主键, 查询条件是否二级索引, 查询条件是否唯一索引和SQL的执行计划都有着很大的关系.</p><p>以 <em>delete from table where id = 1</em> 为例;</p></blockquote><ul><li>RC模式下. 当ID为主键时, 此时只需要在聚簇索引上对应行上加行锁即可实现;</li><li>RC模式下. 当ID非主键但其上有唯一索引时, InnoDB会加两把锁.第一把是在非唯一索引上对满足条件的行加锁.并通过其对应的主键对聚簇索引中的行加锁;为什么会在聚簇索引上加锁呢?因为为了避免其他事务在此时更新ID列;</li><li>RC模式下. 当ID列非主键也无唯一索引时, InnoDB会对全部表中的记录加锁.</li></ul><div class="hint-container tip"><p class="hint-container-title">MySQL 层级</p><p>MySQL是分为两层的Server层和Engine层. Server层负责SQL的解析优化,Engine层负责数据的存取. 当数据无法通过索引进行精准匹配时,Engine层就会把符合条件的数据全部返回. 由Server层对数据进行再次过滤. 只要是在当前读状态下,Engine层返回给Server层的数据都是会加锁的. 但是, 为了效率考量.MySQL对这部分还是做了优化的. 即当Server层过滤后发现多余的数据不需要加锁后,会立即通知Engine层将锁释放,而不是在事务提交时再释放. 显然这是一个反范式优化.违反了2PL的语义.</p></div><ul><li>RR模式下, 当ID列非主键但存在非唯一索引时, InnoDB会加三把锁. 第一把是在非唯一索引对应记录上的行锁, 第二把是在非唯一索引对应记录的前后加入间歇锁, 第三把是在聚簇索引对应主键上加行锁.</li></ul><figure><img src="'+a+'" alt="RR模式" tabindex="0" loading="lazy"><figcaption>RR模式</figcaption></figure><ul><li>RR模式下, 当ID非主键也无唯一索引时. InnoDB会对全表的数据记录加锁.并在此基础上对所有记录间加入间隙锁. 本质上已经是表锁了.</li></ul><figure><img src="'+l+'" alt="RR模式" tabindex="0" loading="lazy"><figcaption>RR模式</figcaption></figure><p><strong>示例</strong>:</p><figure><img src="'+s+'" alt="示例" tabindex="0" loading="lazy"><figcaption>示例</figcaption></figure><p><strong>IndexKey</strong>: 用于查询在索引中的连续范围.</p><p><strong>IndexFilter</strong>: 在使用IndexKey确定了查询的连续范围后, 需要使用其他where条件来进行过滤.</p><p><strong>TableFilter</strong>: where条件中不能通过索引处理的查询条件.</p><p>从上图中可以看出. 在默认的RR模式下, 由IndexKey确定的连续范围将会加上间歇锁. IndexFilter指定的过滤条件将会被加上行锁. IndexFilter在5.6版本前不支持索引下推(ICP),多出来的数据也会被加上行锁 返回给Server层进行处理.这时,二级索引上还会加上红箭头指示的行锁.</p><p><strong>总结</strong>:</p><ol><li>只有在RR模式下, 才会启用间隙锁或NK锁;</li><li>除串行化模式下, 所有DQL语句走的都是快照读.即对数据不加锁;</li><li>Engine层无法通过索引精准匹配的数据, 会由Server层再次过滤.但会全部加锁;</li><li>通过二级索引匹配到的数据会先在二级索引上加锁, 最后通过二级索引对聚簇索引加锁;</li></ol><h2 id="死锁原理与分析" tabindex="-1"><a class="header-anchor" href="#死锁原理与分析" aria-hidden="true">#</a> 死锁原理与分析</h2><p>死锁的发生与否和执行了多少SQL并没有一点关系, 死锁的关键在于, 两个以上的session对同一批共享数据的加锁顺序不一致导致的. 只有了解InnoDB的加锁机制,并根据各自加锁的顺序分析才能找到照成死锁的最终原因.</p>',40),c=[p];function g(h,u){return t(),i("div",null,c)}const m=e(d,[["render",g],["__file","InnoDB-Isolation-Level-And-MVCC-First.html.vue"]]);export{m as default};
