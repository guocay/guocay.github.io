import{_ as e,X as a,Y as i,Z as r}from"./framework-d314e57d.js";const n="/docs/images/20230426-002.png",t={},o=r('<figure><img src="'+n+'" alt="Spring框架refresh函数执行流程" tabindex="0" loading="lazy"><figcaption>Spring框架refresh函数执行流程</figcaption></figure><h2 id="preparerefresh-准备刷新" tabindex="-1"><a class="header-anchor" href="#preparerefresh-准备刷新" aria-hidden="true">#</a> prepareRefresh(): 准备刷新</h2><blockquote><ul><li>设置启动时间</li><li>容器关闭标示符设置为false</li><li>容器可用标示符设置为true</li><li>initPropertySources(): 钩子函数, 初始化属性资源,</li><li>getEnvironment().validateRequiredProperties(): 验证必要属性必须存在.</li><li>清空已有的监听器(如果有的话),并重新从applicationListeners属性中加载</li></ul></blockquote><h2 id="obtainfreshbeanfactory-获取bean工厂" tabindex="-1"><a class="header-anchor" href="#obtainfreshbeanfactory-获取bean工厂" aria-hidden="true">#</a> obtainFreshBeanFactory(): 获取Bean工厂</h2><h3 id="如果上下文中已经存在bean工厂-将先销毁" tabindex="-1"><a class="header-anchor" href="#如果上下文中已经存在bean工厂-将先销毁" aria-hidden="true">#</a> 如果上下文中已经存在Bean工厂,将先销毁.</h3><h3 id="createbeanfactory-创建bean工厂-使用defaultlistablebeanfactory对象" tabindex="-1"><a class="header-anchor" href="#createbeanfactory-创建bean工厂-使用defaultlistablebeanfactory对象" aria-hidden="true">#</a> createBeanFactory(): 创建Bean工厂,使用DefaultListableBeanFactory对象;</h3><h3 id="customizebeanfactory-自定义设置bean工厂" tabindex="-1"><a class="header-anchor" href="#customizebeanfactory-自定义设置bean工厂" aria-hidden="true">#</a> customizeBeanFactory(): 自定义设置Bean工厂</h3><blockquote><ul><li>是否允许Bean定义覆盖</li><li>是否允许循环引用</li></ul></blockquote><h3 id="loadbeandefinitions-加载bean定义信息" tabindex="-1"><a class="header-anchor" href="#loadbeandefinitions-加载bean定义信息" aria-hidden="true">#</a> loadBeanDefinitions(): 加载Bean定义信息</h3><blockquote><ul><li>创建BeanDefinitionReader</li><li>配置BeanDefinitionReader,关联上下文</li><li>initBeanDefinitionReader(): 初始化这个Reader对象</li><li>loadBeanDefinitions(): 加载Bean定义信息</li></ul></blockquote><h2 id="preparebeanfactory-准备bean工厂" tabindex="-1"><a class="header-anchor" href="#preparebeanfactory-准备bean工厂" aria-hidden="true">#</a> prepareBeanFactory(): 准备Bean工厂</h2><h3 id="设置bean工厂的类加载器" tabindex="-1"><a class="header-anchor" href="#设置bean工厂的类加载器" aria-hidden="true">#</a> 设置Bean工厂的类加载器</h3><h3 id="如果不忽略spel表达式-则设置standardbeanexpressionresolver对象用于解析spel表达式" tabindex="-1"><a class="header-anchor" href="#如果不忽略spel表达式-则设置standardbeanexpressionresolver对象用于解析spel表达式" aria-hidden="true">#</a> 如果不忽略SpEL表达式,则设置StandardBeanExpressionResolver对象用于解析SpEL表达式;</h3><h3 id="设置属性编辑注册器" tabindex="-1"><a class="header-anchor" href="#设置属性编辑注册器" aria-hidden="true">#</a> 设置属性编辑注册器</h3><h3 id="添加一个用于aware感知的postprocessor" tabindex="-1"><a class="header-anchor" href="#添加一个用于aware感知的postprocessor" aria-hidden="true">#</a> 添加一个用于Aware感知的PostProcessor</h3><h3 id="忽略一部分aware的实现类-因为这个时候还无法感知这部分动作" tabindex="-1"><a class="header-anchor" href="#忽略一部分aware的实现类-因为这个时候还无法感知这部分动作" aria-hidden="true">#</a> 忽略一部分Aware的实现类, 因为这个时候还无法感知这部分动作</h3><blockquote><ul><li>EnvironmentAware</li><li>EmbeddedValueResolverAware</li><li>ResourceLoaderAware</li><li>ApplicationEventPublisherAware</li><li>MessageSourceAware</li><li>ApplicationContextAware</li><li>ApplicationStartupAware</li></ul></blockquote><h3 id="注册一批-可解析依赖项" tabindex="-1"><a class="header-anchor" href="#注册一批-可解析依赖项" aria-hidden="true">#</a> 注册一批 可解析依赖项</h3><blockquote><ul><li>BeanFactory</li><li>ResourceLoader</li><li>ApplicationEventPublisher</li><li>ApplicationContext</li></ul></blockquote><h3 id="注册一个用于监听探测的postprocessor类" tabindex="-1"><a class="header-anchor" href="#注册一个用于监听探测的postprocessor类" aria-hidden="true">#</a> 注册一个用于监听探测的PostProcessor类.</h3><h3 id="设置-loadtimeweaver" tabindex="-1"><a class="header-anchor" href="#设置-loadtimeweaver" aria-hidden="true">#</a> 设置 LoadTimeWeaver</h3><h3 id="注册一批环境变量" tabindex="-1"><a class="header-anchor" href="#注册一批环境变量" aria-hidden="true">#</a> 注册一批环境变量</h3><blockquote><ul><li>ENVIRONMENT_BEAN_NAME</li><li>SYSTEM_PROPERTIES_BEAN_NAME</li><li>SYSTEM_ENVIRONMENT_BEAN_NAME</li><li>APPLICATION_STARTUP_BEAN_NAME</li></ul></blockquote><h2 id="postprocessbeanfactory-钩子函数-通知子容器beanfactory准备好了" tabindex="-1"><a class="header-anchor" href="#postprocessbeanfactory-钩子函数-通知子容器beanfactory准备好了" aria-hidden="true">#</a> postProcessBeanFactory(): 钩子函数.通知子容器BeanFactory准备好了</h2><h2 id="invokebeanfactorypostprocessors-执行bean工厂后置处理器" tabindex="-1"><a class="header-anchor" href="#invokebeanfactorypostprocessors-执行bean工厂后置处理器" aria-hidden="true">#</a> invokeBeanFactoryPostProcessors(): 执行Bean工厂后置处理器</h2><blockquote><ul><li>添加LoadTimeWeaverAwareProcessor</li><li>添加临时类加载器 ContextTypeMatchClassLoader</li></ul></blockquote><h2 id="registerbeanpostprocessors-注册bean的后置处理器" tabindex="-1"><a class="header-anchor" href="#registerbeanpostprocessors-注册bean的后置处理器" aria-hidden="true">#</a> registerBeanPostProcessors(): 注册Bean的后置处理器</h2><blockquote><ul><li>添加BeanPostProcessor处理器, 通过BeanPostProcessorChecker</li><li>注册支持优先排序的后置处理器</li><li>注册不支持排序的后置处理器(所有的)</li><li>注册内部后置处理器</li><li>添加(处理)内部的监听类型的后置处理器</li></ul></blockquote><h2 id="initmessagesource-初始化消息源" tabindex="-1"><a class="header-anchor" href="#initmessagesource-初始化消息源" aria-hidden="true">#</a> initMessageSource(): 初始化消息源</h2><blockquote><p>判断当前Bean工厂中是否存在 MESSAGE_SOURCE_BEAN_NAME 对象,如不存在则创建 DelegatingMessageSource对象,并注册进容器.如存在则使用工厂中的消息源对象.</p></blockquote><h2 id="initapplicationeventmulticaster-初始化事件传播器" tabindex="-1"><a class="header-anchor" href="#initapplicationeventmulticaster-初始化事件传播器" aria-hidden="true">#</a> initApplicationEventMulticaster(): 初始化事件传播器</h2><blockquote><p>判断当前Bean工厂中是否存在 APPLICATION_EVENT_MULTICASTER_BEAN_NAME 对象,如存在则使用,不存在则创建一个 SimpleApplicationEventMulticaster 对象,并放入工厂</p></blockquote><h2 id="onrefresh-钩子函数-支持子类对刷新的扩展" tabindex="-1"><a class="header-anchor" href="#onrefresh-钩子函数-支持子类对刷新的扩展" aria-hidden="true">#</a> onRefresh(): 钩子函数,支持子类对刷新的扩展</h2><h2 id="registerlisteners-注册监听" tabindex="-1"><a class="header-anchor" href="#registerlisteners-注册监听" aria-hidden="true">#</a> registerListeners(): 注册监听</h2><blockquote><ul><li>将静态指定的事件监听器逐一添加到事件传播器中.</li><li>将动态指定的事件监听器加入时间传播器中.</li><li>发布应用早期事件, 这时应用的事件传播器已经就绪...</li></ul></blockquote><h2 id="finishbeanfactoryinitialization-结束beanfactory初始化-并初始化一些特殊bean对象-比如非懒加载的bean" tabindex="-1"><a class="header-anchor" href="#finishbeanfactoryinitialization-结束beanfactory初始化-并初始化一些特殊bean对象-比如非懒加载的bean" aria-hidden="true">#</a> finishBeanFactoryInitialization(): 结束BeanFactory初始化,并初始化一些特殊Bean对象.比如非懒加载的Bean.</h2><h3 id="初始化上下文转换服务" tabindex="-1"><a class="header-anchor" href="#初始化上下文转换服务" aria-hidden="true">#</a> 初始化上下文转换服务.</h3><h3 id="如果没有指定-标签解析器-就使用环境中的默认转换器进行转换-getenvironment-resolveplaceholders-strval" tabindex="-1"><a class="header-anchor" href="#如果没有指定-标签解析器-就使用环境中的默认转换器进行转换-getenvironment-resolveplaceholders-strval" aria-hidden="true">#</a> 如果没有指定 标签解析器, 就使用环境中的默认转换器进行转换 getEnvironment().resolvePlaceholders(strVal).</h3><h3 id="尽早初始化-loadtimeweaveraware-bean-以便尽早注册其变压器。" tabindex="-1"><a class="header-anchor" href="#尽早初始化-loadtimeweaveraware-bean-以便尽早注册其变压器。" aria-hidden="true">#</a> 尽早初始化 LoadTimeWeaverAware bean，以便尽早注册其变压器。</h3><h3 id="设置临时类加载器为null-停止使用临时类加载器" tabindex="-1"><a class="header-anchor" href="#设置临时类加载器为null-停止使用临时类加载器" aria-hidden="true">#</a> 设置临时类加载器为null, 停止使用临时类加载器.</h3><h3 id="freezeconfiguration-冻结所有bean定义信息" tabindex="-1"><a class="header-anchor" href="#freezeconfiguration-冻结所有bean定义信息" aria-hidden="true">#</a> freezeConfiguration(): 冻结所有bean定义信息.</h3><blockquote><ul><li>设置 冻结 标示符 为true</li><li>为 frozenBeanDefinitionNames 赋值</li></ul></blockquote><h3 id="preinstantiatesingletons-初始化非懒加载的bean" tabindex="-1"><a class="header-anchor" href="#preinstantiatesingletons-初始化非懒加载的bean" aria-hidden="true">#</a> preInstantiateSingletons(): 初始化非懒加载的bean</h3><h4 id="重新包装-beandefinitionnames-属性为一个arraylist" tabindex="-1"><a class="header-anchor" href="#重新包装-beandefinitionnames-属性为一个arraylist" aria-hidden="true">#</a> 重新包装 beanDefinitionNames 属性为一个ArrayList</h4><h4 id="循环上一步包装的集合-根据beanname创建bean" tabindex="-1"><a class="header-anchor" href="#循环上一步包装的集合-根据beanname创建bean" aria-hidden="true">#</a> 循环上一步包装的集合, 根据beanName创建bean</h4><h5 id="getmergedlocalbeandefinition-根据beanname获取本地bean定义信息缓存" tabindex="-1"><a class="header-anchor" href="#getmergedlocalbeandefinition-根据beanname获取本地bean定义信息缓存" aria-hidden="true">#</a> getMergedLocalBeanDefinition(): 根据beanName获取本地bean定义信息缓存.</h5><h5 id="判断获取的beandefinition所代表的bean-非抽象类-是单例-非懒加载" tabindex="-1"><a class="header-anchor" href="#判断获取的beandefinition所代表的bean-非抽象类-是单例-非懒加载" aria-hidden="true">#</a> 判断获取的BeanDefinition所代表的bean 非抽象类, 是单例, 非懒加载</h5><h5 id="判断是否为factorybean的子类" tabindex="-1"><a class="header-anchor" href="#判断是否为factorybean的子类" aria-hidden="true">#</a> 判断是否为FactoryBean的子类</h5><h6 id="是则" tabindex="-1"><a class="header-anchor" href="#是则" aria-hidden="true">#</a> 是则</h6><blockquote><ul><li>调用getBean() 获取这个工厂bean的实例, 获取时需要添加前缀 FACTORY_BEAN_PREFIX</li><li>判断 上一步获取到的对象是否为FactoryBean的子类实例</li><li>判断是否为SmartFactroyBean的子类实例</li><li>获取当前FactoryBean是否希望初始化(isEagerInit());</li><li>是则, 再次通过getBean加载此对象(本次不再添加前缀)</li></ul></blockquote><h6 id="非则-调用-getbean-创建bean实例" tabindex="-1"><a class="header-anchor" href="#非则-调用-getbean-创建bean实例" aria-hidden="true">#</a> 非则, 调用 getBean() 创建bean实例</h6><blockquote><ul><li>transformedBeanName(): 规范化beanName</li><li>getSingleton(): 在单例池中获取当前对象</li></ul></blockquote><h4 id="循环上上一步创建的集合-根据beanname获取已经创建好的bean-并判断bean是否为-smartinitializingsingleton的子类实例-是则运行bean的aftersingletonsinstantiated函数" tabindex="-1"><a class="header-anchor" href="#循环上上一步创建的集合-根据beanname获取已经创建好的bean-并判断bean是否为-smartinitializingsingleton的子类实例-是则运行bean的aftersingletonsinstantiated函数" aria-hidden="true">#</a> 循环上上一步创建的集合, 根据beanName获取已经创建好的bean, 并判断bean是否为 SmartInitializingSingleton的子类实例, 是则运行bean的afterSingletonsInstantiated函数.</h4><h2 id="finishrefresh-结束刷新-并发布结束刷新事件" tabindex="-1"><a class="header-anchor" href="#finishrefresh-结束刷新-并发布结束刷新事件" aria-hidden="true">#</a> finishRefresh(): 结束刷新, 并发布结束刷新事件.</h2><h3 id="clearresourcecaches-清空资源缓存" tabindex="-1"><a class="header-anchor" href="#clearresourcecaches-清空资源缓存" aria-hidden="true">#</a> clearResourceCaches(): 清空资源缓存</h3><blockquote><p>清空 DefaultResourceLoader 中的 resourceCaches 对象</p></blockquote><h3 id="initlifecycleprocessor-初始化生命周期管理" tabindex="-1"><a class="header-anchor" href="#initlifecycleprocessor-初始化生命周期管理" aria-hidden="true">#</a> initLifecycleProcessor(): 初始化生命周期管理</h3><blockquote><p>判断Bean工厂中是否存在 LIFECYCLE_PROCESSOR_BEAN_NAME 对象, 不存在则创建一个 DefaultLifecycleProcessor对象;</p></blockquote><h3 id="getlifecycleprocessor-onrefresh-刷新生命周期管理器" tabindex="-1"><a class="header-anchor" href="#getlifecycleprocessor-onrefresh-刷新生命周期管理器" aria-hidden="true">#</a> getLifecycleProcessor().onRefresh(): 刷新生命周期管理器</h3><blockquote><ul><li>startBeans(): 启动bean的生命周期</li><li>将 running 标识符设置为 true</li></ul></blockquote><h3 id="发布上下文刷新事件" tabindex="-1"><a class="header-anchor" href="#发布上下文刷新事件" aria-hidden="true">#</a> 发布上下文刷新事件</h3><blockquote><p>通过上下文的 publish函数 发布 ContextRefreshedEvent 对象</p></blockquote><h3 id="参与-livebeansview-mbean-如果处于活动状态" tabindex="-1"><a class="header-anchor" href="#参与-livebeansview-mbean-如果处于活动状态" aria-hidden="true">#</a> 参与 LiveBeansView MBean（如果处于活动状态）</h3>',63),s=[o];function l(h,d){return a(),i("div",null,s)}const b=e(t,[["render",l],["__file","Spring-Refresh-Method-Process.html.vue"]]);export{b as default};
