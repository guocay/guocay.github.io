const e=JSON.parse('{"key":"v-50cca39e","path":"/article/JVM-Class-Load-Process.html","title":"Java虚拟机类加载过程","lang":"zh-CN","frontmatter":{"title":"Java虚拟机类加载过程","icon":"note","isOriginal":true,"date":"2023-04-26T00:00:00.000Z","tag":["JVM"],"category":"Java","description":"Java虚拟机类加载过程 loadClass(): 对应加载阶段 根据类名获取锁对象, 并通过synchronized加锁. 这个加锁操作保证了只会有一个线程对当前类进行加载, 解决了多线程重复加载的问题. findLoadedClass(): 在JVM方法区找一下是否存在当前Class对象并返回.","head":[["meta",{"property":"og:url","content":"https://guocay.github.io/article/JVM-Class-Load-Process.html"}],["meta",{"property":"og:site_name","content":"GuoCay"}],["meta",{"property":"og:title","content":"Java虚拟机类加载过程"}],["meta",{"property":"og:description","content":"Java虚拟机类加载过程 loadClass(): 对应加载阶段 根据类名获取锁对象, 并通过synchronized加锁. 这个加锁操作保证了只会有一个线程对当前类进行加载, 解决了多线程重复加载的问题. findLoadedClass(): 在JVM方法区找一下是否存在当前Class对象并返回."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-05-18T11:09:04.000Z"}],["meta",{"property":"article:author","content":"GuoCay"}],["meta",{"property":"article:tag","content":"JVM"}],["meta",{"property":"article:published_time","content":"2023-04-26T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-05-18T11:09:04.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java虚拟机类加载过程\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-04-26T00:00:00.000Z\\",\\"dateModified\\":\\"2023-05-18T11:09:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"GuoCay\\",\\"email\\":\\"guocay@gmail.com\\"}]}"]]},"headers":[{"level":2,"title":"loadClass(): 对应加载阶段","slug":"loadclass-对应加载阶段","link":"#loadclass-对应加载阶段","children":[{"level":3,"title":"根据类名获取锁对象, 并通过synchronized加锁.","slug":"根据类名获取锁对象-并通过synchronized加锁","link":"#根据类名获取锁对象-并通过synchronized加锁","children":[]},{"level":3,"title":"findLoadedClass(): 在JVM方法区找一下是否存在当前Class对象并返回.","slug":"findloadedclass-在jvm方法区找一下是否存在当前class对象并返回","link":"#findloadedclass-在jvm方法区找一下是否存在当前class对象并返回","children":[]},{"level":3,"title":"如果上一步没找到Class类","slug":"如果上一步没找到class类","link":"#如果上一步没找到class类","children":[]},{"level":3,"title":"resolveClass(): 如果设置需要解析, 则校验Class对象.","slug":"resolveclass-如果设置需要解析-则校验class对象","link":"#resolveclass-如果设置需要解析-则校验class对象","children":[]}]},{"level":2,"title":"defineClass(): 对应链接阶段(验证, 准备, 解析)","slug":"defineclass-对应链接阶段-验证-准备-解析","link":"#defineclass-对应链接阶段-验证-准备-解析","children":[{"level":3,"title":"preDefineClass(): 定义类前的处理逻辑(确定保护域)","slug":"predefineclass-定义类前的处理逻辑-确定保护域","link":"#predefineclass-定义类前的处理逻辑-确定保护域","children":[]},{"level":3,"title":"defineClassSourceLocation(): 定义类资源位置","slug":"defineclasssourcelocation-定义类资源位置","link":"#defineclasssourcelocation-定义类资源位置","children":[]},{"level":3,"title":"defineClass1(): native函数, 将二进制数组转换为一个Class对象","slug":"defineclass1-native函数-将二进制数组转换为一个class对象","link":"#defineclass1-native函数-将二进制数组转换为一个class对象","children":[]},{"level":3,"title":"postDefineClass(): 定义类后的处理逻辑","slug":"postdefineclass-定义类后的处理逻辑","link":"#postdefineclass-定义类后的处理逻辑","children":[]}]}],"git":{"createdTime":1684408144000,"updatedTime":1684408144000,"contributors":[{"name":"GuoCay","email":"guocay@gmail.com","commits":1}]},"readingTime":{"minutes":3.19,"words":957},"filePathRelative":"article/JVM-Class-Load-Process.md","localizedDate":"2023年4月26日","excerpt":"<figure><img src=\\"/docs/images/20230426-004.png\\" alt=\\"Java虚拟机类加载过程\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>Java虚拟机类加载过程</figcaption></figure>\\n<h2> loadClass(): 对应加载阶段</h2>\\n<h3> 根据类名获取锁对象, 并通过synchronized加锁.</h3>\\n<blockquote>\\n<p>这个加锁操作保证了只会有一个线程对当前类进行加载, 解决了多线程重复加载的问题.</p>\\n</blockquote>\\n<h3> findLoadedClass(): 在JVM方法区找一下是否存在当前Class对象并返回.</h3>","autoDesc":true}');export{e as data};
