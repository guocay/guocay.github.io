import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as s,a as n}from"./app-BTSdHDNU.js";const l="/docs/images/20230426-004.png",o={},c=n('<figure><img src="'+l+'" alt="Java虚拟机类加载过程" tabindex="0" loading="lazy"><figcaption>Java虚拟机类加载过程</figcaption></figure><h2 id="loadclass-对应加载阶段" tabindex="-1"><a class="header-anchor" href="#loadclass-对应加载阶段"><span>loadClass(): 对应加载阶段</span></a></h2><h3 id="根据类名获取锁对象-并通过synchronized加锁" tabindex="-1"><a class="header-anchor" href="#根据类名获取锁对象-并通过synchronized加锁"><span>根据类名获取锁对象, 并通过synchronized加锁.</span></a></h3><blockquote><p>这个加锁操作保证了只会有一个线程对当前类进行加载, 解决了多线程重复加载的问题.</p></blockquote><h3 id="findloadedclass-在jvm方法区找一下是否存在当前class对象并返回" tabindex="-1"><a class="header-anchor" href="#findloadedclass-在jvm方法区找一下是否存在当前class对象并返回"><span>findLoadedClass(): 在JVM方法区找一下是否存在当前Class对象并返回.</span></a></h3><h4 id="checkname-查验类名是否符合规范" tabindex="-1"><a class="header-anchor" href="#checkname-查验类名是否符合规范"><span>checkName(): 查验类名是否符合规范</span></a></h4><blockquote><p>其实就是看这个字符串是否符合java类名命名规范.</p></blockquote><h4 id="findloadedclass0-native函数-从方法区查验当前类是否存在" tabindex="-1"><a class="header-anchor" href="#findloadedclass0-native函数-从方法区查验当前类是否存在"><span>findLoadedClass0(): native函数, 从方法区查验当前类是否存在.</span></a></h4><h3 id="如果上一步没找到class类" tabindex="-1"><a class="header-anchor" href="#如果上一步没找到class类"><span>如果上一步没找到Class类</span></a></h3><h4 id="记录当前时间" tabindex="-1"><a class="header-anchor" href="#记录当前时间"><span>记录当前时间</span></a></h4><h4 id="查看是否设置了父加载器" tabindex="-1"><a class="header-anchor" href="#查看是否设置了父加载器"><span>查看是否设置了父加载器</span></a></h4><h5 id="找到了-调用父加载器的loadclass" tabindex="-1"><a class="header-anchor" href="#找到了-调用父加载器的loadclass"><span>找到了, 调用父加载器的loadClass()</span></a></h5><blockquote><ul><li><p>这一步也保证了类的单一加载器加载, 也保障了类的静态代码块有且仅运行一次.</p></li><li><p>这一步是双亲委派实现的原理.</p></li></ul></blockquote><h5 id="findbootstrapclassornull-没找到-尝试调用-bootstrampclassloader加载当前类" tabindex="-1"><a class="header-anchor" href="#findbootstrapclassornull-没找到-尝试调用-bootstrampclassloader加载当前类"><span>findBootstrapClassOrNull(): 没找到, 尝试调用 BootstrampClassLoader加载当前类.</span></a></h5><h6 id="checkname-校验名称是否合法-不合法则返回" tabindex="-1"><a class="header-anchor" href="#checkname-校验名称是否合法-不合法则返回"><span>checkName(): 校验名称是否合法, 不合法则返回.</span></a></h6><h6 id="findbootstrapclass-native函数-通过-bootstrapclassloader加载类" tabindex="-1"><a class="header-anchor" href="#findbootstrapclass-native函数-通过-bootstrapclassloader加载类"><span>findBootstrapClass(): native函数, 通过 BootstrapClassLoader加载类.</span></a></h6><h4 id="如果上一步还是没找到" tabindex="-1"><a class="header-anchor" href="#如果上一步还是没找到"><span>如果上一步还是没找到.</span></a></h4><h5 id="再次记录当前时间" tabindex="-1"><a class="header-anchor" href="#再次记录当前时间"><span>再次记录当前时间.</span></a></h5><h5 id="调用当前类加载器的findclass-获取类" tabindex="-1"><a class="header-anchor" href="#调用当前类加载器的findclass-获取类"><span>调用当前类加载器的findClass()获取类.</span></a></h5><h5 id="记录类加载器指标" tabindex="-1"><a class="header-anchor" href="#记录类加载器指标"><span>记录类加载器指标</span></a></h5><h6 id="记录去父加载器中查找的耗时" tabindex="-1"><a class="header-anchor" href="#记录去父加载器中查找的耗时"><span>记录去父加载器中查找的耗时</span></a></h6><h6 id="记录加载器开始查找时间" tabindex="-1"><a class="header-anchor" href="#记录加载器开始查找时间"><span>记录加载器开始查找时间</span></a></h6><h6 id="记录加载类找到的类个数" tabindex="-1"><a class="header-anchor" href="#记录加载类找到的类个数"><span>记录加载类找到的类个数.</span></a></h6><h3 id="resolveclass-如果设置需要解析-则校验class对象" tabindex="-1"><a class="header-anchor" href="#resolveclass-如果设置需要解析-则校验class对象"><span>resolveClass(): 如果设置需要解析, 则校验Class对象.</span></a></h3><blockquote><p>就是看一下这个类是否还是空,是则抛出空指针异常.</p></blockquote><h2 id="defineclass-对应链接阶段-验证-准备-解析" tabindex="-1"><a class="header-anchor" href="#defineclass-对应链接阶段-验证-准备-解析"><span>defineClass(): 对应链接阶段(验证, 准备, 解析)</span></a></h2><h3 id="predefineclass-定义类前的处理逻辑-确定保护域" tabindex="-1"><a class="header-anchor" href="#predefineclass-定义类前的处理逻辑-确定保护域"><span>preDefineClass(): 定义类前的处理逻辑(确定保护域)</span></a></h3><h4 id="checkname-检查类名" tabindex="-1"><a class="header-anchor" href="#checkname-检查类名"><span>checkName(): 检查类名</span></a></h4><h4 id="校验类名不以-java-开头-且不是platformclassloader-这个类在jdk8前叫extclassloader" tabindex="-1"><a class="header-anchor" href="#校验类名不以-java-开头-且不是platformclassloader-这个类在jdk8前叫extclassloader"><span>校验类名不以&quot;java.&quot;开头,且不是PlatformClassLoader(这个类在jdk8前叫ExtClassLoader)</span></a></h4><blockquote><p>否则抛出安全异常</p></blockquote><h4 id="如果保护域对象为空-则赋值为默认保护域" tabindex="-1"><a class="header-anchor" href="#如果保护域对象为空-则赋值为默认保护域"><span>如果保护域对象为空, 则赋值为默认保护域.</span></a></h4><h4 id="checkcerts-认证当前类所属的包是否在签名内-否则抛出安全异常" tabindex="-1"><a class="header-anchor" href="#checkcerts-认证当前类所属的包是否在签名内-否则抛出安全异常"><span>checkCerts(): 认证当前类所属的包是否在签名内.否则抛出安全异常</span></a></h4><h3 id="defineclasssourcelocation-定义类资源位置" tabindex="-1"><a class="header-anchor" href="#defineclasssourcelocation-定义类资源位置"><span>defineClassSourceLocation(): 定义类资源位置</span></a></h3><blockquote><p>从ProtectionDomain的CodeSource中获取位置信息.</p></blockquote><h3 id="defineclass1-native函数-将二进制数组转换为一个class对象" tabindex="-1"><a class="header-anchor" href="#defineclass1-native函数-将二进制数组转换为一个class对象"><span>defineClass1(): native函数, 将二进制数组转换为一个Class对象</span></a></h3><h4 id="验证-可以通过虚拟机关闭验证阶段以加快类的加载-但不建议这么做-折中的方法可以让虚拟机预热类" tabindex="-1"><a class="header-anchor" href="#验证-可以通过虚拟机关闭验证阶段以加快类的加载-但不建议这么做-折中的方法可以让虚拟机预热类"><span>验证(可以通过虚拟机关闭验证阶段以加快类的加载. 但不建议这么做. 折中的方法可以让虚拟机预热类)</span></a></h4><h5 id="文件格式验证" tabindex="-1"><a class="header-anchor" href="#文件格式验证"><span>文件格式验证</span></a></h5><blockquote><p>魔数开头, JVM版本号...</p></blockquote><h5 id="元数据验证" tabindex="-1"><a class="header-anchor" href="#元数据验证"><span>元数据验证</span></a></h5><blockquote><p>是否有继承链, 继承是否合法...</p></blockquote><h5 id="字节码验证" tabindex="-1"><a class="header-anchor" href="#字节码验证"><span>字节码验证</span></a></h5><blockquote><p>最复杂的部分, 验证指令是否合法, 指针是否合法, 不会对虚拟机造成伤害...</p></blockquote><h5 id="符号引用验证" tabindex="-1"><a class="header-anchor" href="#符号引用验证"><span>符号引用验证</span></a></h5><blockquote><p>将符号引用转换为实际引用(伴随着解析部分),并校验是否合法.</p></blockquote><h4 id="准备" tabindex="-1"><a class="header-anchor" href="#准备"><span>准备</span></a></h4><blockquote><p>为类中的静态变量开辟内存空间.</p></blockquote><h4 id="解析" tabindex="-1"><a class="header-anchor" href="#解析"><span>解析</span></a></h4><h5 id="接口-类-解析" tabindex="-1"><a class="header-anchor" href="#接口-类-解析"><span>接口(类)解析</span></a></h5><blockquote><p>接口在方法区的内存位置信息.</p></blockquote><h5 id="字段解析" tabindex="-1"><a class="header-anchor" href="#字段解析"><span>字段解析</span></a></h5><blockquote><p>将函数或类中用到的属性的相对偏移量转换出来. 比如, 指向常量池中的实际地址.</p></blockquote><h5 id="方法解析" tabindex="-1"><a class="header-anchor" href="#方法解析"><span>方法解析</span></a></h5><blockquote><p>就是将类的元信息在方法区内存中的偏移量赋给方法区中的类.供对象后续调用时使用. 这是一个内存地址信息(JVM管理的内存地址)</p></blockquote><h4 id="初始化-非构造函数" tabindex="-1"><a class="header-anchor" href="#初始化-非构造函数"><span>初始化(非构造函数)</span></a></h4><blockquote><ul><li>收集当前类中的静态代码块信息, 并执行.</li><li>收集编译器生产的赋值操作后,生成的静态代码.并执行.</li></ul></blockquote><h3 id="postdefineclass-定义类后的处理逻辑" tabindex="-1"><a class="header-anchor" href="#postdefineclass-定义类后的处理逻辑"><span>postDefineClass(): 定义类后的处理逻辑</span></a></h3><h4 id="getnamedpackage-定义一个命名包-放到当前classloader中-如果不存在" tabindex="-1"><a class="header-anchor" href="#getnamedpackage-定义一个命名包-放到当前classloader中-如果不存在"><span>getNamedPackage(): 定义一个命名包,放到当前ClassLoader中, 如果不存在.</span></a></h4><h4 id="如果安全域中的codesource中的签名不为空-则将签名放到当前class类中" tabindex="-1"><a class="header-anchor" href="#如果安全域中的codesource中的签名不为空-则将签名放到当前class类中"><span>如果安全域中的CodeSource中的签名不为空.则将签名放到当前class类中.</span></a></h4><blockquote><p>setSigners(): native函数.</p></blockquote>',59),t=[c];function d(i,r){return e(),s("div",null,t)}const f=a(o,[["render",d],["__file","JVM-Class-Load-Process.html.vue"]]),b=JSON.parse('{"path":"/article/JVM-Class-Load-Process.html","title":"Java虚拟机类加载过程","lang":"zh-CN","frontmatter":{"title":"Java虚拟机类加载过程","icon":"note","isOriginal":true,"date":"2023-04-26T00:00:00.000Z","tag":["JVM"],"category":"Java","description":"Java虚拟机类加载过程Java虚拟机类加载过程 loadClass(): 对应加载阶段 根据类名获取锁对象, 并通过synchronized加锁. 这个加锁操作保证了只会有一个线程对当前类进行加载, 解决了多线程重复加载的问题. findLoadedClass(): 在JVM方法区找一下是否存在当前Class对象并返回. checkName(): 查...","head":[["meta",{"property":"og:url","content":"https://blog.guocay.com/article/JVM-Class-Load-Process.html"}],["meta",{"property":"og:site_name","content":"GuoCay"}],["meta",{"property":"og:title","content":"Java虚拟机类加载过程"}],["meta",{"property":"og:description","content":"Java虚拟机类加载过程Java虚拟机类加载过程 loadClass(): 对应加载阶段 根据类名获取锁对象, 并通过synchronized加锁. 这个加锁操作保证了只会有一个线程对当前类进行加载, 解决了多线程重复加载的问题. findLoadedClass(): 在JVM方法区找一下是否存在当前Class对象并返回. checkName(): 查..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://blog.guocay.com/docs/images/20230426-004.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-05-18T11:09:04.000Z"}],["meta",{"property":"article:author","content":"GuoCay"}],["meta",{"property":"article:tag","content":"JVM"}],["meta",{"property":"article:published_time","content":"2023-04-26T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-05-18T11:09:04.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java虚拟机类加载过程\\",\\"image\\":[\\"https://blog.guocay.com/docs/images/20230426-004.png\\"],\\"datePublished\\":\\"2023-04-26T00:00:00.000Z\\",\\"dateModified\\":\\"2023-05-18T11:09:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"GuoCay\\",\\"email\\":\\"guocay@gmail.com\\"}]}"]]},"headers":[{"level":2,"title":"loadClass(): 对应加载阶段","slug":"loadclass-对应加载阶段","link":"#loadclass-对应加载阶段","children":[{"level":3,"title":"根据类名获取锁对象, 并通过synchronized加锁.","slug":"根据类名获取锁对象-并通过synchronized加锁","link":"#根据类名获取锁对象-并通过synchronized加锁","children":[]},{"level":3,"title":"findLoadedClass(): 在JVM方法区找一下是否存在当前Class对象并返回.","slug":"findloadedclass-在jvm方法区找一下是否存在当前class对象并返回","link":"#findloadedclass-在jvm方法区找一下是否存在当前class对象并返回","children":[]},{"level":3,"title":"如果上一步没找到Class类","slug":"如果上一步没找到class类","link":"#如果上一步没找到class类","children":[]},{"level":3,"title":"resolveClass(): 如果设置需要解析, 则校验Class对象.","slug":"resolveclass-如果设置需要解析-则校验class对象","link":"#resolveclass-如果设置需要解析-则校验class对象","children":[]}]},{"level":2,"title":"defineClass(): 对应链接阶段(验证, 准备, 解析)","slug":"defineclass-对应链接阶段-验证-准备-解析","link":"#defineclass-对应链接阶段-验证-准备-解析","children":[{"level":3,"title":"preDefineClass(): 定义类前的处理逻辑(确定保护域)","slug":"predefineclass-定义类前的处理逻辑-确定保护域","link":"#predefineclass-定义类前的处理逻辑-确定保护域","children":[]},{"level":3,"title":"defineClassSourceLocation(): 定义类资源位置","slug":"defineclasssourcelocation-定义类资源位置","link":"#defineclasssourcelocation-定义类资源位置","children":[]},{"level":3,"title":"defineClass1(): native函数, 将二进制数组转换为一个Class对象","slug":"defineclass1-native函数-将二进制数组转换为一个class对象","link":"#defineclass1-native函数-将二进制数组转换为一个class对象","children":[]},{"level":3,"title":"postDefineClass(): 定义类后的处理逻辑","slug":"postdefineclass-定义类后的处理逻辑","link":"#postdefineclass-定义类后的处理逻辑","children":[]}]}],"git":{"createdTime":1684408144000,"updatedTime":1684408144000,"contributors":[{"name":"GuoCay","email":"guocay@gmail.com","commits":1}]},"readingTime":{"minutes":3.19,"words":957},"localizedDate":"2023年4月26日","excerpt":"<figure><img src=\\"/docs/images/20230426-004.png\\" alt=\\"Java虚拟机类加载过程\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>Java虚拟机类加载过程</figcaption></figure>\\n<h2>loadClass(): 对应加载阶段</h2>\\n<h3>根据类名获取锁对象, 并通过synchronized加锁.</h3>\\n<blockquote>\\n<p>这个加锁操作保证了只会有一个线程对当前类进行加载, 解决了多线程重复加载的问题.</p>\\n</blockquote>\\n<h3>findLoadedClass(): 在JVM方法区找一下是否存在当前Class对象并返回.</h3>","autoDesc":true}');export{f as comp,b as data};
